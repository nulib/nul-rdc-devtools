#!/bin/bash -e
if [[ -n $DEBUG ]]; then set -x; fi

asdf-backup() {
  echo "Saving list of asdf plugins and versions" >&2
  installed="{}"
  for p in $(asdf plugin list); do
    installed=$(jq --arg plugin $p '. + { ($plugin): [] }' <<< $installed)
    for v in $(asdf list $p); do
      installed=$(jq --arg plugin $p --arg version $v '.[$plugin] |= . + [$version]' <<< $installed)
    done
  done
  mkdir -p $HOME/.backup-ide/asdf
  echo $installed > $HOME/.backup-ide/asdf/installed.json
}

asdf-restore() {
  if [[ -e $HOME/.backup-ide/asdf/installed.json ]]; then
    set +e
    installed=$(cat $HOME/.backup-ide/asdf/installed.json)
    echo "Reinstalling asdf plugins and versions" >&2
    for p in $(jq -r 'keys[]' <<< $installed); do
      asdf plugin add $p
      for v in $(jq -r --arg plugin $p '.[$plugin][]' <<< $installed); do
        asdf install $p $v
      done
    done
    set -e
  fi
}

vscode-flavor-backup() {
  codename=${1:-code}
  if [[ -e $HOME/.${codename}-server ]]; then
    commit=$(ls -t $HOME/.${codename}-server/bin/ 2>/dev/null | head -1)
    if [[ -n $commit && -e $HOME/.${codename}-server/bin/${commit}/bin/${codename##vs}-server ]]; then
      echo "Backing up $codename extensions & settings" >&2
      mkdir -p $HOME/.backup-ide/${codename}
      arch=$($HOME/.${codename}-server/bin/${commit}/bin/${codename##vs}-server --version | tail -1)
      jq --arg commit $commit --arg arch $arch '. += {"commit": $commit, "arch": $arch}' < $HOME/.${codename}-server/bin/${commit}/package.json > $HOME/.backup-ide/${codename}/version
      $HOME/.${codename}-server/bin/${commit}/bin/${codename##vs}-server --list-extensions > $HOME/.backup-ide/${codename}/extensions
      if [[ -e $HOME/.${codename}-server/data/Machine/settings.json ]]; then
        cp $HOME/.${codename}-server/data/Machine/settings.json $HOME/.backup-ide/${codename}/
      fi
    fi
  fi
}

vscode-flavor-restore() {
  codename=${1:-code}
  if [[ -e $HOME/.backup-ide/${codename}/version ]]; then
    echo "Restoring $codename extensions & settings" >&2
    version_info=$(cat $HOME/.backup-ide/${codename}/version)
    commit=$(jq -r '.commit' <<< $version_info)
    version=$(jq -r '[.version, .release] | map(select(length > 0)) | join(".")' <<< $version_info)

    case $(uname -i) in
      aarch64 | arm64)
        arch="arm64"
        ;;
      *)
        arch="x64"
        ;;
    esac
    echo "ARCH IS: $arch"

    mkdir -p $HOME/.${codename}-server/bin/${commit}
    if [[ $codename == "codium" ]]; then
      DOWNLOAD_URL=https://github.com/VSCodium/vscodium/releases/download/${version}/vscodium-reh-linux-${arch}-${version}.tar.gz
    else
      DOWNLOAD_URL=https://update.code.visualstudio.com/commit:${commit}/server-linux-${arch}/stable
    fi
    curl -Ls $DOWNLOAD_URL | tar xz --strip-components=1 -C $HOME/.${codename}-server/bin/${commit}

    if [[ -e $HOME/.backup-ide/${codename}/extensions ]]; then
      install_params=""
      for ext in $(cat $HOME/.backup-ide/${codename}/extensions); do
        install_params="$install_params --install-extension $ext"
      done
      $HOME/.${codename}-server/bin/${commit}/bin/${codename##vs}-server $install_params
    fi

    if [[ -e $HOME/.backup-ide/${codename}/settings.json ]]; then
      mkdir -p $HOME/.${codename}-server/data/Machine
      cp  $HOME/.backup-ide/${codename}/settings.json $HOME/.${codename}-server/data/Machine/settings.json
    fi
  fi
}

vscode-backup() {
  vscode-flavor-backup vscode
  vscode-flavor-backup vscodium
  vscode-flavor-backup cursor
}

vscode-restore() {
  vscode-flavor-restore vscode
  vscode-flavor-restore vscodium
  vscode-flavor-restore cursor
}

backup-prefix() {
  INSTANCE_ID=$(curl -s http://169.254.169.254/latest/meta-data/instance-id)
  TAG_DATA=$(aws ec2 describe-tags --filters Name=resource-id,Values=$INSTANCE_ID)
  OWNER=$(jq -r '.Tags[] | select(.Key == "Owner") | .Value' <<< $TAG_DATA)
  PREFIX=${1:-${OWNER}}
  echo $PREFIX
}

config-value() {
  aws secretsmanager get-secret-value --secret-id "dev-environment/terraform/common" --query "SecretString" --output text \
    | jq -r .${1}
}

shared-bucket() {
  config-value shared_bucket_arn | rev | cut -d ':' -f1 | rev
}

backup-repository() {
  echo "s3:s3.amazonaws.com/$1/homes/$2"
}

links-backup() {
  pushd $HOME
  find . -type l | xargs tar cjf $HOME/.backup-ide/symlinks.tar.bz2 --exclude-from=$HOME/.nul-rdc-devtools/helpers/backup-ignore
  popd
}

links-restore() {
  tar xjf $HOME/.backup-ide/symlinks.tar.bz2 -C $HOME
}

config-restic() {
  SHARED_BUCKET=$(shared-bucket)
  PREFIX=$(backup-prefix $2)
  RESTIC_REPOSITORY=$(backup-repository $SHARED_BUCKET $PREFIX)
  RESTIC_PASSWORD=$(config-value backup_key)
}

restic-command() {
  credfile=$(ls -t ~/.aws/cli/cache/ | head -1)  
  eval export $(cat ~/.aws/cli/cache/$credfile | jq -r '.Credentials | "AWS_ACCESS_KEY_ID=\(.AccessKeyId) AWS_SECRET_ACCESS_KEY=\(.SecretAccessKey) AWS_SESSION_TOKEN=\(.SessionToken)"')
  restic $@
  STATUS=$?
  unset AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN
  return $STATUS
}

home-backup() {
  config-restic
  if ! restic-command cat config > /dev/null 2>&1; then
    echo "Initializing backup repository at $RESTIC_REPOSITORY" >&2
    restic-command init
  fi
  echo "Backing up $HOME to $RESTIC_REPOSITORY" >&2
  restic-command backup --exclude-if-present .no-backup --exclude-file $HOME/.nul-rdc-devtools/helpers/backup-ignore $HOME
}

home-restore() {
  config-restic
  if ! restic-command cat config > /dev/null 2>&1; then
    echo "No backup repository at $RESTIC_REPOSITORY" >&2
    return 1
  fi
  echo "Restoring $HOME from $RESTIC_REPOSITORY/" >&2
  restic-command restore latest --target $HOME
}

package-backup() {
  dnf repoquery --qf '%{name}' --userinstalled > $HOME/.backup-ide/installed_packages.txt
}

package-restore() {
  if [[ -e $HOME/.backup-ide/installed_packages.txt ]]; then
    < $HOME/.backup-ide/installed_packages.txt xargs sudo dnf -y install
  fi
}

display-help() {
  cat <<__EOC__ >&2
This script will back up your home directory to a shared S3 bucket so it can be
restored later during an environment refresh or replacement. In order to minimize
the time and storage required, things like project dependencies and build 
artifacts (e.g., \`deps\`, \`node_modules\`, \`_build\`) are excluded from the backup,
as well as cache files.

Tools installed under ASDF are not backed up, but a record of what plugins and 
versions were installed at the time of the backup is included, and the restore
operation will reinstall them during the restore. The same is true of Visual Code
server, plugins, and settings.

Commands:

    backup [BASENAME]     Initiate a backup, overwriting any existing backup
                          already in place.

    restore [BASENAME]    Initiate a restore, overwriting the existing home
                          directory.
  
    delete [BASENAME]     Delete an existing backup.

    help                  Display this help message.

All operations use s3://$(shared-bucket)/homes/BASENAME.tar.gz as the backup
location. If BASENAME is not provided, the EC2 instance's Owner tag will be used.
__EOC__
  echo
}

COMMAND=$1

should() {
  action=$(tr a-z A-Z <<< $1)
  target=$(tr a-z A-Z <<< $2)
  flag_name=NO_${action}_${target}
  flag=${!flag_name}
  if [[ -z $flag ]]; then
    true
  else
    false
  fi
}

case $COMMAND in
  backup)
    for component in asdf vscode links package home; do
      if should backup $component; then
        ${component}-backup $@
      fi
    done
    ;;
  restore)
    for component in home package vscode links asdf; do
      if should restore $component; then
        ${component}-restore $@
      fi
    done
    ;;
  delete)
    SHARED_BUCKET=$(shared-bucket)
    FILE=$(backup-filename $2)
    aws s3 rm s3://$SHARED_BUCKET/homes/$FILE
    ;;
  help)
    display-help
    ;;
  *)
    echo "Unknown command: $1" >&2
    echo "USAGE: $0 <backup|restore|delete|help> [basename]" >&2
    ;;
esac
